.data
	base: .word 0
	expoente: .word 0
	modulo: .word 0
	
	string:                 .asciiz "A exponencial modular "
	string1:                .asciiz " elevado a "
	string2:                .asciiz " (mod "
	string3:                .asciiz ") eh "
	stringPonto:            .asciiz "."
	stringEntradaInvalida:  .asciiz "Entradas invalidas."
	stringModuloNaoPrimo:   .asciiz "O modulo nao eh primo."
	stringfinal:		.asciiz "Saiu."
	space:                  .asciiz "\n"
.text

main:
	#Leitura dos números:
	
	#leitura base
 	li $v0, 5
 	sw $v0, base
 	syscall
 	move $s0, $v0

 	#leitura expoente
 	li $v0, 5
 	sw $v0, expoente
 	syscall
 	move $s1, $v0
 	
 	#leitura modulo
 	li $v0, 5
 	sw $v0, modulo
 	syscall
 	move $s2, $v0	
	
	
	#Verificação da Validação das Entradas:
	
	addi $t0, $zero, 32767 #Preparando $9 para comparar com as entradas e constatar se são menores ou iguais que 65535
	addi $t0, $t0, 32767
	addi $t0, $t0, 2 # t0 -> 32767 + 32767 + 2 = 65356 
	
	slt $t3, $0, $s0 #Verificar se a base é maior que 0,
	beq $t2, $t3, imprimirErroEntradaInvalida #Caso seja menor ou igual a 0, imprimirErroEntradaInvalida
	slt $t3, $s0, $t0 #Verificar se a base é menor que 65536
	beq $t3, $zero, imprimirErroEntradaInvalida #Caso seja maior que 65536, imprimirErroEntradaInvalida
	
	slt $t3, $0, $s1 #Verificar se o expoente é maior que 0,
	beq $t2, $t3, imprimirErroEntradaInvalida #Caso seja menor ou igual a 0, imprimirErroEntradaInvalida
	slt $t3, $s1, $t0 #Verificar se o expoente é menor que 65536
	beq $t3, $zero, imprimirErroEntradaInvalida #Caso seja maior que 65536, imprimirErroEntradaInvalida
	
	slt $t3, $0, $s2 #Verificar se o modulo é maior que 0,
	beq $t2, $t3, imprimirErroEntradaInvalida #Caso seja menor ou igual a 0, imprimirErroEntradaInvalida
	slt $t3, $s2, $t0 #Verificar se o modulo é menor que 65536
	beq $t3, $zero, imprimirErroEntradaInvalida #Caso seja maior que 65536, imprimirErroEntradaInvalida
	
	
	#Verificação se o Módulo é um Número Primo:

	addi $t0, $zero, 256 #Limite do laço forPrimoMaior
	add $t6, $zero, $s2  #Limite do laço forPrimoMenor
	
	li $t5, 0 #contador
	
	#Verificar se o Módulo é par:
	
	li $t2, 2
	div $t3,$s2,$t2 #divisao entre o módulo e 2
 	mfhi $t7 #resto da divisão
 	
 	bne $t7, $0, moduloImpar #Se resto da divisao for igual a 0
		jal moduloPar #Se resto da divisao for diferente que 0
		
	moduloPar:
 		
 		slt $t1, $t2, $s2 #Se modulo é maior ou menor que 2
 		bne $t1, $0, impressaoErroPrimo #Se módulo for menor que 2, entra em forPrimoMenor256
			jal moduloImpar #Se módulo for maior que 256, 2 em forPrimoMaior256

	moduloImpar:

		slt $t1, $s2, $t0 #Se modulo é maior ou menor que 256
		bne $t1, $0, forPrimoMenor256 #Se módulo for menor que 256, entra em forPrimoMenor256
			jal forPrimoMaior256 #Se módulo for maior que 256, entra em forPrimoMaior256
		
		li $v0, 10 #saida, fim de programa na Main
 		syscall	
	
	
	li $v0, 10 #saida, fim de programa na Main
 	syscall
	
	
forPrimoMenor256:
 	
 	li $t4, 1
 	beq $t4, $t6, validacaoPrimo
 	
 	li $t4, 2
 	beq $t4, $t6, validacaoPrimo
 		
 	li $t4, 3
 	auxforPrimoMenor:
 		beq $t4,$t6,validacaoPrimo #enquanto $t4 != 256($t0), laço forPrimo funciona
 	
 	
 		div $t3,$s2,$t4 #divisao entre o módulo e o indice ($s2 / $t4)
	 	mfhi $t7 #resto da divisão
 	
	 	add $t4,$t4,2 #incremento de indice ($t4)
	 	
 		beq $t7, $zero, auxFor1 #Se resto($t7) for igual 0,auxiliar é incrementado o auxiliar e volta pro laço forPrimoMenor256
 			j auxforPrimoMenor #Se resto($t7) for diferente de 0,volta a fazer o laço forPrimoMenor256
 	
		auxFor1:
			add $t5,$t5,1 #Incrementado do auxiliar
			j auxforPrimoMenor #volta a fazer o laço forPrimoMenor256
 														
forPrimoMaior256:
 
 	beq $t4,$0,validacaoPrimo
 	
 
 	div $t6,$s2,$t4 #divisao entre o módulo e o indice ($s2 / $t4)	 	mfhi $t7 #resto da divisão
 	mfhi $t7 #resto da divisão
	
	add $t4,$t4,2 #incremento de indice ($t4)
	 	
	beq $t7, $zero, auxFor2 #Se resto($t7) for igual 0,auxiliar é incrementado o auxiliar e volta pro laço forPrimoMenor256	 	j forPrimoMaior256 #Se resto($t7) for diferente de 0,volta a fazer o laço forPrimoMenor256
 		j forPrimoMaior256 #Se resto($t7) for diferente de 0,volta a fazer o laço forPrimoMaior256
 	
 	auxFor2:
 		
 		add $t5,$t5,1 #Incrementado do auxiliar
 		jal forPrimoMaior256 #volta a fazer o laço forPrimoMenor256
	

validacaoPrimo:
 	
 	li $t4, 1
 	beq $t6, $t4, impressaoErroPrimo
 	
 	beq $t5, $0, exponenciacao #Se módulo for menor que 2, entra em forPrimoMenor256
		jal impressaoErroPrimo #Se módulo for maior que 256, 2 em forPrimoMaior256
 	
 	
 	#saida
 	li $v0, 10
 	syscall	


exponenciacao:
	
 	li $v0, 4
	la $a0, stringfinal
	syscall

	#saida
 	li $v0, 10
 	syscall
 	
 	#calculo exponencial
 	add $t0,$zero, $s0 #FAT
 	addi $t1, $zero, 0 #indice
 	addi $t6,$zero, 1 #FatFinal
 	
forExponenciacao:
 	beq $t1,16,Saida
 	beq $t1,$zero,primeiroCaso
 	mulu $t3,$t0,$t0
 	divu $t3,$s2
 	
 	mfhi $t5
 	
 	add $t0,$zero,$t5
 	
 	mulu $t6,$t6,$t0
 	divu $t6,$s2
 	
 	mfhi $t7
 	
 	add $t6, $zero, $t7
 	addi $t1,$t1, 1
 	j forExponenciacao
 	
 primeiroCaso:
 	add $t2,$zero, $t0
 	
 	mulu $t6,$t6,$t0
 	divu $t6,$s2
 	
 	mfhi $t7
 	
 	add $t6, $zero, $t7
 	addi $t1,$t1, 1
 	j forExponenciacao
 	
 	
Saida:
 	#impressao resultado calculo exponencial
	li $v0, 4
 	la $a0, string
 	syscall
 	
 	li $v0, 1
 	move $a0, $s0
 	syscall
 	
 	li $v0, 4
 	la $a0, string1
 	syscall
 	
 	li $v0, 1
 	move $a0, $s1
 	syscall
 	
 	li $v0, 4
 	la $a0, string2
 	syscall
 	
 	li $v0, 1
 	move $a0, $s2
 	syscall
 	
 	li $v0, 4
 	la $a0, string3
 	syscall
 	
 	li $v0, 1
 	move $a0, $t6
 	syscall
 	
 	li $v0, 4
 	la $a0, stringPonto
 	syscall
 	
 	#impressao space
 	li $v0, 4
 	la $a0, space
 	syscall
 	
	#saida
	li $v0, 10
 	syscall
 	
 
#impressao String Entradas Inválidas
imprimirErroEntradaInvalida:
 	li $v0, 4	
 	la $a0, stringEntradaInvalida
 	syscall
 	
 	#impressao space
 	li $v0, 4
 	la $a0, space
 	syscall
 	
 	li $v0, 10 #saida
 	syscall
 	
 	
#impressao String Modulo Nao Primo
impressaoErroPrimo:

	li $v0, 4
 	la $a0, stringModuloNaoPrimo
 	syscall
 	
 	#impressao space
 	li $v0, 4
 	la $a0, space
 	syscall
 	
 	#saida
 	li $v0, 10
 	syscall